package com.mj.algo.greedy;

import java.util.Comparator;
import java.util.PriorityQueue;

/*
 * Prefix Codes, means the codes (bit sequences) are assigned in such a way that the code 
 * assigned to one character is not the prefix of code assigned to any other character. 
 * This is how Huffman Coding makes sure that there is no ambiguity when decoding the generated 
 * bitstream.
 */

class HuffmanNode{
	int frequency;
	char ch;
	HuffmanNode left;
	HuffmanNode right;
}

class MyComparator implements Comparator<HuffmanNode> { 
    public int compare(HuffmanNode x, HuffmanNode y) 
    { 
        return x.frequency - y.frequency; 
    } 
} 



public class HuffmanCode {

	
	 public static void printCode(HuffmanNode root, String s) 
	    { 
	  
	        // base case; if the left and right are null 
	        // then its a leaf node and we print 
	        // the code generated by traversing the tree. 
	        if (root.left 
	                == null
	            && root.right 
	                   == null
	            && Character.isLetter(root.ch)) { 
	  
	            // c is the character in the node 
	            System.out.println(root.ch + ":" + s); 
	  
	            return; 
	        } 
	  
	        // if we go to left then add "0" to the code. 
	        // if we go to the right add"1" to the code. 
	  
	        // recursive calls for left and 
	        // right sub-tree of the generated tree. 
	        printCode(root.left, s + "0"); 
	        printCode(root.right, s + "1"); 
	    } 
	
	
	public static void main(String[] args) {
		
		int n = 6;
		char[] charArray = { 'a', 'b', 'c', 'd', 'e', 'f' }; 
	    int[] charfreq = { 15, 9, 12, 13, 16, 45 };
		
		PriorityQueue<HuffmanNode> pq = new PriorityQueue<HuffmanNode>(6, new MyComparator());
		
		for (int i = 0; i < n; i++) { 
			HuffmanNode hn = new HuffmanNode();
			hn.frequency = charfreq[i];
			hn.ch = charArray[i];
			hn.left = null; 
            hn.right = null; 
			pq.add(hn);
		}
		
		HuffmanNode root = null;
		while(pq.size()>1) {
			HuffmanNode first = pq.poll();
			HuffmanNode second = pq.poll();
			root = new HuffmanNode();
			root.frequency = first.frequency+second.frequency;
			root.ch = '-';
			root.left = first; 
			root.right = second; 
            pq.add(root);
         
		}
		
		 // print the codes by traversing the tree 
        printCode(root, ""); 
		
	}

}
